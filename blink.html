<!DOCTYPE html>
<html>
<head>
  <title>Blink Chaos Mode</title>
  <style>
    body {
        margin: 0;
        overflow: hidden;
        background: rgb(204, 15, 81);
        color: lime;
        font-family: monospace;
      text-align: center;
    }

    #start-btn {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 20px;
      background: red;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }

    #chaos-text {
      font-size: 2em;
      position: absolute;
      bottom: 100px;
      width: 100%;
      text-align: center;
    }

    .camera-container {
      position: relative;
      width: 640px;
      height: 480px;
      margin: 80px auto 0 auto;
      border: 3px solid lime;
      box-shadow: 0 0 30px red;
    }

    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    @media (max-width: 700px) {
      .camera-container {
        width: 100vw;
        height: auto;
        box-shadow: none;
        border: none;
      }

      canvas, video {
        width: 100vw !important;
        height: auto !important;
      }

      #chaos-text {
        font-size: 1.2em;
      }}
      </style
</head>
<body>
  <button id="start-btn">Start Chaos</button>
  <div class="camera-container">
    <video id="webcam" autoplay playsinline muted width="640" height="480" style="display:none;"></video>
    <canvas id="canvas" width="640" height="480"></canvas>
  </div>
  <div id="chaos-text"></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    const roastLines = [
      "YOU FOOL! YOU BLINKED.",
      "SYSTEM FAILURE DETECTED.",
      "RETINAL REBOOT IN 3... 2...",
      "ERROR: TOO MUCH HUMANITY.",
      "BLINK RECEIVED. SENDING SIGNAL TO NASA.",
      "DID THAT BLINK SOLVE WORLD HUNGER? NO.",
      "REALLY? AGAIN?",
      "PLEASE STOP. FOR YOUR OWN SAFETY.",
      "EVERY BLINK SETS US BACK 10 YEARS.",
      "CRITICAL BLINK. INITIATE CHAOS PROTOCOL."
    ];

    let blinkCount = 0;
    let blinked = false;

    const video = document.getElementById('webcam');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const chaosText = document.getElementById('chaos-text');

    const LEFT_EYE = [33, 160, 158, 133, 153, 144];
    const RIGHT_EYE = [362, 385, 387, 263, 373, 380];

    function dist(p1, p2) {
      return Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }

    function eyeRatio(landmarks, eye) {
      const top = (dist(landmarks[eye[1]], landmarks[eye[5]]) +
                  dist(landmarks[eye[2]], landmarks[eye[4]])) / 2;
      const side = dist(landmarks[eye[0]], landmarks[eye[3]]);
      return top / side;
    }

    const soundUrls = [
      "https://www.soundjay.com/explosion/explosion-01.mp3",
      "https://www.soundjay.com/button/beep-07.wav",
      "https://www.soundjay.com/button/beep-10.wav",
      "https://www.soundjay.com/button/beep-01a.wav",
      "https://www.soundjay.com/human/scream-01.wav",
      "https://www.soundjay.com/misc/sounds/buzzer-1.mp3"
    ];

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    async function playWithEffect(url, effectType = "robot") {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;

      if (effectType === "robot") {
        const biquad = audioContext.createBiquadFilter();
        biquad.type = "bandpass";
        biquad.frequency.value = 800;
        biquad.Q.value = 1;
        source.connect(biquad);
        biquad.connect(audioContext.destination);
      } else if (effectType === "demonic") {
        const gain = audioContext.createGain();
        gain.gain.value = 1.5;

        const delay = audioContext.createDelay();
        delay.delayTime.value = 0.2;

        const feedback = audioContext.createGain();
        feedback.gain.value = 0.6;

        delay.connect(feedback);
        feedback.connect(delay);

        source.connect(delay);
        delay.connect(audioContext.destination);
        source.connect(gain);
        gain.connect(audioContext.destination);
      }

      source.start();
    }

    function unleashChaos() {
      const roast = roastLines[Math.floor(Math.random() * roastLines.length)];
      const sound = soundUrls[Math.floor(Math.random() * soundUrls.length)];
      chaosText.textContent = `${roast}`;
      playWithEffect(sound, Math.random() < 0.5 ? "robot" : "demonic");

      document.body.style.background = 'white';
      setTimeout(() => {
        document.body.style.background = 'black';
      }, 100);
    }

    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    faceMesh.onResults((results) => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];
        const lRatio = eyeRatio(landmarks, LEFT_EYE);
        const rRatio = eyeRatio(landmarks, RIGHT_EYE);
        const avg = (lRatio + rRatio) / 2;

        if (avg < 0.22 && !blinked) {
          blinked = true;
          blinkCount++;
          unleashChaos();
        } else if (avg > 0.25) {
          blinked = false;
        }

        ctx.fillStyle = 'lime';
        ctx.font = '20px monospace';
        ctx.fillText(`BLINK COUNT: ${blinkCount}`, 20, 30);
      }
    });

    document.getElementById('start-btn').onclick = async () => {
      await audioContext.resume();
      document.getElementById('start-btn').style.display = 'none';
      video.style.display = 'block';

      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;

      const camera = new Camera(video, {
        onFrame: async () => {
          await faceMesh.send({ image: video });
        },
        width: 640,
        height: 480
      });

      camera.start();
    };
  </script>
</body>
</html>
